<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        /* Auth Styles */
        .auth-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .auth-box {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 400px;
        }

        .auth-box h2 {
            margin-bottom: 24px;
            color: #333;
            text-align: center;
        }

        .auth-box input {
            width: 100%;
            padding: 12px;
            margin-bottom: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .auth-box input:focus {
            outline: none;
            border-color: #667eea;
        }

        .auth-box button {
            width: 100%;
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }

        .auth-box button:hover {
            background: #5568d3;
        }

        .toggle-link {
            text-align: center;
            margin-top: 16px;
            color: #667eea;
            cursor: pointer;
            font-size: 14px;
        }

        .toggle-link:hover {
            text-decoration: underline;
        }

        .error-message {
            background: #fee;
            color: #c33;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }

        /* Main App */
        .app-container {
            display: none;
            height: 100vh;
            background: #fff;
        }

        .app-container.active {
            display: flex;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #34495e;
        }

        .sidebar-header {
            padding: 20px;
            background: #1a252f;
            border-bottom: 1px solid #34495e;
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .user-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }

        .user-info h3 {
            font-size: 16px;
            margin-bottom: 4px;
        }

        .user-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #95a5a6;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #27ae60;
        }

        /* Conversations */
        .conversation-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .conversation-item {
            padding: 16px 20px;
            cursor: pointer;
            transition: background 0.3s;
            border-left: 3px solid transparent;
        }

        .conversation-item:hover {
            background: #34495e;
        }

        .conversation-item.active {
            background: #34495e;
            border-left-color: #667eea;
        }

        .conversation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .conversation-name {
            font-weight: 600;
            font-size: 14px;
        }

        .conversation-time {
            font-size: 11px;
            color: #95a5a6;
        }

        .conversation-preview {
            font-size: 13px;
            color: #95a5a6;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Chat Area */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ecf0f1;
        }

        .chat-header {
            padding: 20px;
            background: white;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-info h2 {
            font-size: 18px;
            margin-bottom: 4px;
            color: #2c3e50;
        }

        .chat-header-status {
            font-size: 13px;
            color: #95a5a6;
        }

        .chat-header-actions {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .header-btn:hover {
            background: #5568d3;
        }

        /* Messages */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .message {
            display: flex;
            gap: 12px;
            max-width: 70%;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.sent {
            margin-left: auto;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
        }

        .message-content {
            flex: 1;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .message-sender {
            font-weight: 600;
            font-size: 13px;
            color: #2c3e50;
        }

        .message-time {
            font-size: 11px;
            color: #95a5a6;
        }

        .message-bubble {
            background: white;
            padding: 10px 14px;
            border-radius: 12px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.5;
        }

        .message.sent .message-bubble {
            background: #667eea;
            color: white;
        }

        /* Message Input */
        .message-input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #ddd;
        }

        .message-input-wrapper {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 24px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }

        .message-input:focus {
            border-color: #667eea;
        }

        .send-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: background 0.3s;
        }

        .send-btn:hover {
            background: #5568d3;
        }

        /* Call Overlay */
        .call-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }

        .call-overlay.active {
            display: flex;
        }

        .call-container {
            text-align: center;
            color: white;
        }

        .call-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            margin: 0 auto 24px;
        }

        .call-participant {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .call-status {
            font-size: 18px;
            color: #95a5a6;
            margin-bottom: 8px;
        }

        .call-timer {
            font-size: 16px;
            color: #7f8c8d;
            margin-bottom: 32px;
        }

        .call-controls {
            display: flex;
            gap: 16px;
            justify-content: center;
        }

        .call-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 24px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .call-btn.accept {
            background: #27ae60;
            color: white;
        }

        .call-btn.accept:hover {
            background: #229954;
        }

        .call-btn.reject, .call-btn.end {
            background: #e74c3c;
            color: white;
        }

        .call-btn.reject:hover, .call-btn.end:hover {
            background: #c0392b;
        }

        .call-btn.mute {
            background: #3498db;
            color: white;
        }

        .call-btn.mute:hover {
            background: #2980b9;
        }

        .call-btn.mute.muted {
            background: #95a5a6;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
            min-width: 300px;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .toast-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #2c3e50;
        }

        .toast-body {
            font-size: 14px;
            color: #7f8c8d;
        }

        /* Empty state */
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #95a5a6;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .empty-state-text {
            font-size: 18px;
        }

        /* Audio elements (hidden) */
        .audio-container {
            display: none;
        }
    </style>
</head>
<body>
<!-- Auth Container -->
<div id="authContainer" class="auth-container">
    <div class="auth-box">
        <h2 id="authTitle">Login</h2>
        <div id="errorMessage" class="error-message"></div>

        <div id="loginForm">
            <input type="text" id="loginUsername" placeholder="Username" />
            <input type="password" id="loginPassword" placeholder="Password" />
            <button onclick="login()">Login</button>
            <div class="toggle-link" onclick="toggleAuthForm()">Don't have an account? Register</div>
        </div>

        <div id="registerForm" style="display: none;">
            <input type="text" id="registerUsername" placeholder="Username" />
            <input type="password" id="registerPassword" placeholder="Password" />
            <input type="text" id="registerDisplayName" placeholder="Display Name" />
            <button onclick="register()">Register</button>
            <div class="toggle-link" onclick="toggleAuthForm()">Already have an account? Login</div>
        </div>
    </div>
</div>

<!-- Main App Container -->
<div id="appContainer" class="app-container">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <div class="user-profile">
                <div class="user-avatar" id="userAvatar">A</div>
                <div class="user-info">
                    <h3 id="userName">Loading...</h3>
                    <div class="user-status">
                        <span class="status-indicator"></span>
                        <span>Online</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="conversation-list" id="conversationList">
            <!-- Conversations will be rendered here -->
        </div>
    </div>

    <!-- Chat Area -->
    <div class="chat-area">
        <div id="chatHeader" class="chat-header" style="display: none;">
            <div class="chat-header-info">
                <h2 id="chatName">Select a conversation</h2>
                <div class="chat-header-status" id="chatStatus">Offline</div>
            </div>
            <div class="chat-header-actions">
                <button class="header-btn" onclick="startCall()">ðŸ“ž Call</button>
            </div>
        </div>

        <div id="messagesContainer" class="messages-container">
            <div class="empty-state">
                <div class="empty-state-icon">ðŸ’¬</div>
                <div class="empty-state-text">Select a conversation to start chatting</div>
            </div>
        </div>

        <div id="messageInputContainer" class="message-input-container" style="display: none;">
            <div class="message-input-wrapper">
                <input
                        type="text"
                        id="messageInput"
                        class="message-input"
                        placeholder="Type a message..."
                        onkeypress="handleMessageKeyPress(event)"
                />
                <button class="send-btn" onclick="sendMessage()">âž¤</button>
            </div>
        </div>
    </div>
</div>

<!-- Call Overlay -->
<div id="callOverlay" class="call-overlay">
    <div class="call-container">
        <div class="call-avatar" id="callAvatar">ðŸ‘¤</div>
        <div class="call-participant" id="callParticipant">Unknown</div>
        <div class="call-status" id="callStatus">Calling...</div>
        <div class="call-timer" id="callTimer">00:00</div>
        <div class="call-controls" id="callControls">
            <!-- Buttons will be dynamically added -->
        </div>
    </div>
</div>

<!-- Hidden audio elements for remote audio streams -->
<div class="audio-container">
    <audio id="remoteAudio" autoplay></audio>
    <audio id="localAudio" muted></audio>
</div>

<script>
    // ==================== CONFIGURATION ====================
    const API_BASE = 'http://192.168.100.110:8080';
    const WS_BASE = 'ws://192.168.100.110:8080';

    // ==================== STATE ====================
    const state = {
        token: localStorage.getItem('token'),
        user: null,
        ws: null,
        conversations: [],
        currentConversation: null,
        messages: new Map(),
        onlineUsers: new Set(),
        activeCall: null,
        callTimer: null,
        // WebRTC
        peerConnection: null,
        localStream: null,
        isMuted: false,
        isInitiator: false,
        pendingIceCandidates: []
    };

    // ==================== WEBRTC CONFIGURATION ====================
    const rtcConfig = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };

    // ==================== INITIALIZATION ====================
    async function init() {
        if (state.token) {
            try {
                await fetchCurrentUser();
                await connectWebSocket();
                await loadConversations();
                showApp();
            } catch (error) {
                console.error('Initialization error:', error);
                logout();
            }
        }
    }

    // ==================== AUTH FUNCTIONS ====================
    function toggleAuthForm() {
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const authTitle = document.getElementById('authTitle');

        if (loginForm.style.display === 'none') {
            loginForm.style.display = 'block';
            registerForm.style.display = 'none';
            authTitle.textContent = 'Login';
        } else {
            loginForm.style.display = 'none';
            registerForm.style.display = 'block';
            authTitle.textContent = 'Register';
        }
        hideError();
    }

    async function login() {
        const username = document.getElementById('loginUsername').value;
        const password = document.getElementById('loginPassword').value;

        if (!username || !password) {
            showError('Please fill in all fields');
            return;
        }

        try {
            const response = await fetch(`${API_BASE}/auth/login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });

            const data = await response.json();

            if (response.ok) {
                state.token = data.token;
                state.user = data.user;
                localStorage.setItem('token', data.token);
                await connectWebSocket();
                await loadConversations();
                showApp();
            } else {
                showError(data.error || 'Login failed');
            }
        } catch (error) {
            showError('Connection error');
            console.error('Login error:', error);
        }
    }

    async function register() {
        const username = document.getElementById('registerUsername').value;
        const password = document.getElementById('registerPassword').value;
        const displayName = document.getElementById('registerDisplayName').value;

        if (!username || !password || !displayName) {
            showError('Please fill in all fields');
            return;
        }

        try {
            const response = await fetch(`${API_BASE}/auth/register`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password, displayName })
            });

            const data = await response.json();

            if (response.ok) {
                state.token = data.token;
                state.user = data.user;
                localStorage.setItem('token', data.token);
                await connectWebSocket();
                await loadConversations();
                showApp();
            } else {
                showError(data.error || 'Registration failed');
            }
        } catch (error) {
            showError('Connection error');
            console.error('Registration error:', error);
        }
    }

    function logout() {
        if (state.ws) {
            state.ws.close();
        }
        if (state.peerConnection) {
            state.peerConnection.close();
        }
        if (state.localStream) {
            state.localStream.getTracks().forEach(track => track.stop());
        }
        localStorage.removeItem('token');
        state.token = null;
        state.user = null;
        location.reload();
    }

    function showError(message) {
        const errorEl = document.getElementById('errorMessage');
        errorEl.textContent = message;
        errorEl.style.display = 'block';
    }

    function hideError() {
        document.getElementById('errorMessage').style.display = 'none';
    }

    function showApp() {
        document.getElementById('authContainer').style.display = 'none';
        document.getElementById('appContainer').classList.add('active');

        if (state.user) {
            document.getElementById('userName').textContent = state.user.displayName;
            document.getElementById('userAvatar').textContent = state.user.displayName[0].toUpperCase();
        }
    }

    // ==================== API FUNCTIONS ====================
    async function apiRequest(endpoint, options = {}) {
        const response = await fetch(`${API_BASE}${endpoint}`, {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${state.token}`,
                ...options.headers
            }
        });

        if (response.status === 401) {
            logout();
            throw new Error('Unauthorized');
        }

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Request failed');
        }

        return response.json();
    }

    async function fetchCurrentUser() {
        state.user = await apiRequest('/users/me');
    }

    async function loadConversations() {
        try {
            const dms = await apiRequest('/dms');
            state.conversations = dms;
            renderConversationList();
        } catch (error) {
            console.error('Error loading conversations:', error);
        }
    }

    // ==================== WEBSOCKET ====================
    async function connectWebSocket() {
        return new Promise((resolve, reject) => {
            state.ws = new WebSocket(`${WS_BASE}/ws?token=${state.token}`);

            state.ws.onopen = () => {
                console.log('WebSocket connected');
                // Start ping interval
                setInterval(() => {
                    if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                        state.ws.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 30000);
                resolve();
            };

            state.ws.onmessage = (event) => {
                handleWebSocketMessage(event.data);
            };

            state.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                reject(error);
            };

            state.ws.onclose = () => {
                console.log('WebSocket disconnected');
                setTimeout(() => {
                    if (state.token) {
                        connectWebSocket();
                    }
                }, 3000);
            };
        });
    }

    function handleWebSocketMessage(data) {
        try {
            const message = JSON.parse(data);
            console.log('WebSocket message:', message.type);

            switch (message.type) {
                case 'pong':
                    break;
                case 'new_message':
                    handleNewMessage(JSON.parse(message.data));
                    break;
                case 'user_status':
                    handleUserStatus(JSON.parse(message.data));
                    break;
                case 'call_initiated':
                    handleIncomingCall(JSON.parse(message.data));
                    break;
                case 'call_status':
                    handleCallStatus(JSON.parse(message.data));
                    break;
                case 'webrtc_offer':
                    handleWebRTCOffer(JSON.parse(message.data));
                    break;
                case 'webrtc_answer':
                    handleWebRTCAnswer(JSON.parse(message.data));
                    break;
                case 'ice_candidate':
                    handleIceCandidate(JSON.parse(message.data));
                    break;
                case 'call_ended':
                    handleCallEnded(JSON.parse(message.data));
                    break;
                default:
                    console.log('Unknown message type:', message.type);
            }
        } catch (error) {
            console.error('Error handling WebSocket message:', error);
        }
    }

    // ==================== UI RENDERING ====================
    function renderConversationList() {
        const container = document.getElementById('conversationList');
        container.innerHTML = '';

        state.conversations.forEach(conv => {
            const item = document.createElement('div');
            item.className = 'conversation-item';
            if (state.currentConversation?.id === conv.id) {
                item.classList.add('active');
            }

            const statusClass = conv.otherUser.status === 'ONLINE' ? 'online' : 'offline';

            item.innerHTML = `
                <div class="conversation-header">
                    <div class="conversation-name">${escapeHtml(conv.otherUser.displayName)}</div>
                    <div class="conversation-time"></div>
                </div>
                <div class="conversation-preview">
                    <span class="status-indicator ${statusClass}"></span>
                    ${conv.otherUser.status}
                </div>
            `;

            item.onclick = () => selectConversation(conv);
            container.appendChild(item);
        });
    }

    async function selectConversation(conversation) {
        state.currentConversation = conversation;
        renderConversationList();

        document.getElementById('chatHeader').style.display = 'flex';
        document.getElementById('messageInputContainer').style.display = 'block';
        document.getElementById('chatName').textContent = conversation.otherUser.displayName;
        document.getElementById('chatStatus').textContent = conversation.otherUser.status;

        await loadMessages(conversation.id);
    }

    async function loadMessages(conversationId) {
        try {
            const data = await apiRequest(`/dms/${conversationId}/messages?limit=50&offset=0`);
            state.messages.set(conversationId, data.messages || []);
            renderMessages();
        } catch (error) {
            console.error('Error loading messages:', error);
        }
    }

    function renderMessages() {
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '';

        if (!state.currentConversation) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ’¬</div>
                    <div class="empty-state-text">Select a conversation to start chatting</div>
                </div>
            `;
            return;
        }

        const messages = state.messages.get(state.currentConversation.id) || [];

        messages.forEach(msg => {
            const messageEl = createMessageElement(msg);
            container.appendChild(messageEl);
        });

        container.scrollTop = container.scrollHeight;
    }

    function createMessageElement(msg) {
        const isSent = msg.senderId === state.user.id;
        const div = document.createElement('div');
        div.className = `message ${isSent ? 'sent' : ''}`;

        const initial = msg.senderName[0].toUpperCase();

        div.innerHTML = `
            <div class="message-avatar">${initial}</div>
            <div class="message-content">
                <div class="message-header">
                    <span class="message-sender">${escapeHtml(msg.senderName)}</span>
                    <span class="message-time">${formatTime(msg.createdAt)}</span>
                </div>
                <div class="message-bubble">${escapeHtml(msg.content)}</div>
            </div>
        `;

        return div;
    }

    // ==================== MESSAGE FUNCTIONS ====================
    async function sendMessage() {
        if (!state.currentConversation) return;

        const input = document.getElementById('messageInput');
        const content = input.value.trim();

        if (!content) return;

        try {
            await apiRequest(`/dms/${state.currentConversation.id}/messages`, {
                method: 'POST',
                body: JSON.stringify({ content })
            });

            input.value = '';
        } catch (error) {
            console.error('Error sending message:', error);
            showToast('Error', 'Failed to send message');
        }
    }

    function handleMessageKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }

    function handleNewMessage(data) {
        const message = data.message;

        if (message.dmId) {
            const messages = state.messages.get(message.dmId) || [];
            messages.push(message);
            state.messages.set(message.dmId, messages);

            if (state.currentConversation?.id === message.dmId) {
                renderMessages();
            }

            if (message.senderId !== state.user.id) {
                showToast('New Message', `${message.senderName}: ${message.content}`);
            }
        }
    }

    function handleUserStatus(data) {
        console.log('User status update:', data);
        let needsUpdate = false;

        const convIndex = state.conversations.findIndex(
            c => c.otherUser.id === data.userId
        );

        if (convIndex !== -1) {
            state.conversations[convIndex].otherUser.status = data.status;
            needsUpdate = true;
        }

        if (needsUpdate) {
            renderConversationList();
        }
    }

    // ==================== CALL FUNCTIONS ====================
    async function startCall() {
        if (!state.currentConversation) {
            showToast('Error', 'Select a conversation first');
            return;
        }

        try {
            const recipientId = state.currentConversation.otherUser.id;
            const call = await apiRequest('/calls/initiate', {
                method: 'POST',
                body: JSON.stringify({ recipientId })
            });

            state.activeCall = call;
            state.isInitiator = true;
            showCallUI('Calling...', state.currentConversation.otherUser.displayName);

            // Get local media stream
            await getLocalStream();

            // Create peer connection and offer
            await createPeerConnection();
            const offer = await state.peerConnection.createOffer();
            await state.peerConnection.setLocalDescription(offer);

            // Send offer to recipient
            sendWebRTCSignal('webrtc_offer', {
                callId: call.id,
                fromUserId: state.user.id,
                toUserId: recipientId,
                signal: JSON.stringify(offer)
            });

            showToast('Call Started', 'Calling ' + state.currentConversation.otherUser.displayName);
        } catch (error) {
            console.error('Error starting call:', error);
            showToast('Error', 'Failed to start call: ' + error.message);
            cleanupCall();
        }
    }

    async function getLocalStream() {
        try {
            state.localStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                },
                video: false
            });

            // Optionally attach to local audio element for monitoring
            // document.getElementById('localAudio').srcObject = state.localStream;

            console.log('Local stream acquired');
        } catch (error) {
            console.error('Error getting local stream:', error);
            throw new Error('Could not access microphone');
        }
    }

    async function createPeerConnection() {
        state.peerConnection = new RTCPeerConnection(rtcConfig);

        // Add local stream tracks to peer connection
        if (state.localStream) {
            state.localStream.getTracks().forEach(track => {
                state.peerConnection.addTrack(track, state.localStream);
            });
        }

        // Handle incoming remote stream
        state.peerConnection.ontrack = (event) => {
            console.log('Received remote track');
            const remoteAudio = document.getElementById('remoteAudio');
            if (remoteAudio.srcObject !== event.streams[0]) {
                remoteAudio.srcObject = event.streams[0];
                console.log('Remote stream attached');
            }
        };

        // Handle ICE candidates
        state.peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                console.log('Sending ICE candidate');
                const recipientId = state.activeCall.recipientId || 
                    state.activeCall.participants.find(p => p.userId !== state.user.id)?.userId;

                if (recipientId) {
                    sendWebRTCSignal('ice_candidate', {
                        callId: state.activeCall.id,
                        fromUserId: state.user.id,
                        toUserId: recipientId,
                        signal: JSON.stringify(event.candidate)
                    });
                }
            }
        };

        // Handle connection state changes
        state.peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', state.peerConnection.connectionState);
            if (state.peerConnection.connectionState === 'connected') {
                showToast('Call Connected', 'Voice call is now active');
            } else if (state.peerConnection.connectionState === 'failed') {
                showToast('Call Failed', 'Connection failed');
                endCall();
            }
        };

        console.log('Peer connection created');
    }

    function sendWebRTCSignal(type, data) {
        if (state.ws && state.ws.readyState === WebSocket.OPEN) {
            const message = {
                type: type,
                data: JSON.stringify(data)
            };
            console.log('Sending WebRTC signal:', type);
            state.ws.send(JSON.stringify(message));
        }
    }

    async function handleIncomingCall(data) {
        console.log('Incoming call:', data);
        state.activeCall = data.call;
        state.isInitiator = false;
        showCallUI('Incoming Call', data.callerName, true);
        showToast('Incoming Call', data.callerName + ' is calling you');
    }

    async function handleWebRTCOffer(data) {
        console.log('Received WebRTC offer');
        try {
            // Get local stream if we don't have it yet
            if (!state.localStream) {
                await getLocalStream();
            }

            // Create peer connection if we don't have one
            if (!state.peerConnection) {
                await createPeerConnection();
            }

            // Set remote description (the offer)
            const offer = JSON.parse(data.signal);
            await state.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            console.log('Remote description set (offer)');

            // Process any pending ICE candidates
            for (const candidate of state.pendingIceCandidates) {
                await state.peerConnection.addIceCandidate(candidate);
            }
            state.pendingIceCandidates = [];

            // Create and send answer
            const answer = await state.peerConnection.createAnswer();
            await state.peerConnection.setLocalDescription(answer);

            sendWebRTCSignal('webrtc_answer', {
                callId: data.callId,
                fromUserId: state.user.id,
                toUserId: data.fromUserId,
                signal: JSON.stringify(answer)
            });

            console.log('Answer sent');
        } catch (error) {
            console.error('Error handling WebRTC offer:', error);
            showToast('Error', 'Failed to handle call: ' + error.message);
        }
    }

    async function handleWebRTCAnswer(data) {
        console.log('Received WebRTC answer');
        try {
            if (!state.peerConnection) {
                console.error('No peer connection exists');
                return;
            }

            const answer = JSON.parse(data.signal);
            await state.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            console.log('Remote description set (answer)');

            // Process any pending ICE candidates
            for (const candidate of state.pendingIceCandidates) {
                await state.peerConnection.addIceCandidate(candidate);
            }
            state.pendingIceCandidates = [];
        } catch (error) {
            console.error('Error handling WebRTC answer:', error);
        }
    }

    async function handleIceCandidate(data) {
        console.log('Received ICE candidate');
        try {
            const candidate = JSON.parse(data.signal);

            if (state.peerConnection && state.peerConnection.remoteDescription) {
                await state.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.log('ICE candidate added');
            } else {
                // Queue candidates if remote description not set yet
                console.log('Queuing ICE candidate');
                state.pendingIceCandidates.push(new RTCIceCandidate(candidate));
            }
        } catch (error) {
            console.error('Error handling ICE candidate:', error);
        }
    }

    function handleCallStatus(data) {
        if (!state.activeCall || state.activeCall.id !== data.callId) return;

        if (data.status === 'ACTIVE') {
            state.activeCall.status = 'ACTIVE';
            showCallUI('In Call', getCallParticipantName());
            startCallTimer();
        } else if (data.status === 'ENDED') {
            hideCallUI();
            showToast('Call Ended', 'The call has ended');
            cleanupCall();
        }
    }

    function handleCallEnded(data) {
        console.log('Call ended notification');
        if (state.activeCall) {
            hideCallUI();
            showToast('Call Ended', 'The call has ended');
            cleanupCall();
        }
    }

    async function acceptCall() {
        if (!state.activeCall) return;

        try {
            await apiRequest(`/calls/${state.activeCall.id}/accept`, {
                method: 'POST'
            });

            showCallUI('Connecting...', getCallParticipantName());
            showToast('Call Accepted', 'Connecting...');

            // Media stream should already be acquired when handling the offer
        } catch (error) {
            console.error('Error accepting call:', error);
            showToast('Error', 'Failed to accept call');
            cleanupCall();
        }
    }

    async function rejectCall() {
        if (!state.activeCall) return;

        try {
            await apiRequest(`/calls/${state.activeCall.id}/reject`, {
                method: 'POST'
            });

            hideCallUI();
            cleanupCall();
        } catch (error) {
            console.error('Error rejecting call:', error);
            cleanupCall();
        }
    }

    async function endCall() {
        if (!state.activeCall) return;

        try {
            // Notify backend
            await apiRequest(`/calls/${state.activeCall.id}/end`, {
                method: 'POST'
            });

            // Notify peer via WebSocket
            const recipientId = state.activeCall.recipientId || 
                state.activeCall.participants.find(p => p.userId !== state.user.id)?.userId;

            if (recipientId) {
                sendWebRTCSignal('call_ended', {
                    callId: state.activeCall.id,
                    fromUserId: state.user.id,
                    toUserId: recipientId,
                    ended: true
                });
            }

            hideCallUI();
            showToast('Call Ended', 'Call ended');
        } catch (error) {
            console.error('Error ending call:', error);
        } finally {
            cleanupCall();
        }
    }

    function toggleMute() {
        if (!state.localStream) return;

        state.isMuted = !state.isMuted;
        state.localStream.getAudioTracks().forEach(track => {
            track.enabled = !state.isMuted;
        });

        // Update button UI
        const muteBtn = document.querySelector('.call-btn.mute');
        if (muteBtn) {
            if (state.isMuted) {
                muteBtn.classList.add('muted');
                muteBtn.innerHTML = 'ðŸ”‡';
            } else {
                muteBtn.classList.remove('muted');
                muteBtn.innerHTML = 'ðŸ”Š';
            }
        }

        // Notify server
        if (state.activeCall) {
            sendWebRTCSignal('mute_toggle', {
                callId: state.activeCall.id,
                isMuted: state.isMuted
            });
        }

        showToast(state.isMuted ? 'Muted' : 'Unmuted', 
            state.isMuted ? 'Your microphone is muted' : 'Your microphone is active');
    }

    function cleanupCall() {
        // Close peer connection
        if (state.peerConnection) {
            state.peerConnection.close();
            state.peerConnection = null;
        }

        // Stop local stream
        if (state.localStream) {
            state.localStream.getTracks().forEach(track => track.stop());
            state.localStream = null;
        }

        // Clear remote audio
        const remoteAudio = document.getElementById('remoteAudio');
        if (remoteAudio.srcObject) {
            remoteAudio.srcObject.getTracks().forEach(track => track.stop());
            remoteAudio.srcObject = null;
        }

        // Reset state
        state.activeCall = null;
        state.isInitiator = false;
        state.isMuted = false;
        state.pendingIceCandidates = [];
    }

    function showCallUI(status, participant, isIncoming = false) {
        const overlay = document.getElementById('callOverlay');
        const statusEl = document.getElementById('callStatus');
        const participantEl = document.getElementById('callParticipant');
        const controlsEl = document.getElementById('callControls');

        overlay.classList.add('active');
        statusEl.textContent = status;
        participantEl.textContent = participant;

        if (isIncoming) {
            controlsEl.innerHTML = `
                <button class="call-btn accept" onclick="acceptCall()" title="Accept">âœ“</button>
                <button class="call-btn reject" onclick="rejectCall()" title="Reject">âœ—</button>
            `;
        } else {
            controlsEl.innerHTML = `
                <button class="call-btn mute" onclick="toggleMute()" title="Mute">ðŸ”Š</button>
                <button class="call-btn end" onclick="endCall()" title="End Call">âœ—</button>
            `;
        }
    }

    function hideCallUI() {
        const overlay = document.getElementById('callOverlay');
        overlay.classList.remove('active');
        document.getElementById('callTimer').textContent = '00:00';

        if (state.callTimer) {
            clearInterval(state.callTimer);
            state.callTimer = null;
        }
    }

    function startCallTimer() {
        let seconds = 0;
        state.callTimer = setInterval(() => {
            seconds++;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('callTimer').textContent =
                `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }, 1000);
    }

    function getCallParticipantName() {
        if (!state.activeCall) return '';
        if (state.currentConversation) {
            return state.currentConversation.otherUser.displayName;
        }
        return 'Unknown';
    }

    // ==================== UTILITY FUNCTIONS ====================
    function formatTime(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diff = now - date;

        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);

        if (minutes < 1) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        if (days < 7) return `${days}d ago`;

        return date.toLocaleDateString();
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function showToast(title, message, duration = 5000) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.innerHTML = `
            <div class="toast-title">${title}</div>
            <div class="toast-body">${escapeHtml(message)}</div>
        `;

        document.body.appendChild(toast);

        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, duration);

        return toast;
    }

    // ==================== START APPLICATION ====================
    init();
</script>
</body>
</html>
