<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        /* Auth Styles */
        .auth-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .auth-box {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 400px;
        }

        .auth-box h2 {
            margin-bottom: 24px;
            color: #333;
            text-align: center;
        }

        .auth-box input {
            width: 100%;
            padding: 12px;
            margin-bottom: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .auth-box input:focus {
            outline: none;
            border-color: #667eea;
        }

        .auth-box button {
            width: 100%;
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }

        .auth-box button:hover {
            background: #5568d3;
        }

        .toggle-link {
            text-align: center;
            margin-top: 16px;
            color: #667eea;
            cursor: pointer;
            font-size: 14px;
        }

        .toggle-link:hover {
            text-decoration: underline;
        }

        .error-message {
            background: #fee;
            color: #c33;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }

        /* Main App */
        .app-container {
            display: none;
            height: 100vh;
            background: #fff;
        }

        .app-container.active {
            display: flex;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #34495e;
        }

        .sidebar-header {
            padding: 20px;
            background: #1a252f;
            border-bottom: 1px solid #34495e;
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .user-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }

        .user-info h3 {
            font-size: 16px;
            margin-bottom: 4px;
        }

        .user-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #95a5a6;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #27ae60;
        }

        /* Conversations */
        .conversation-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .conversation-item {
            padding: 16px 20px;
            cursor: pointer;
            transition: background 0.3s;
            border-left: 3px solid transparent;
        }

        .conversation-item:hover {
            background: #34495e;
        }

        .conversation-item.active {
            background: #34495e;
            border-left-color: #667eea;
        }

        .conversation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .conversation-name {
            font-weight: 600;
            font-size: 14px;
        }

        .conversation-time {
            font-size: 11px;
            color: #95a5a6;
        }

        .conversation-preview {
            font-size: 13px;
            color: #95a5a6;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Chat Area */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ecf0f1;
        }

        .chat-header {
            padding: 20px;
            background: white;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-info h2 {
            font-size: 18px;
            margin-bottom: 4px;
            color: #2c3e50;
        }

        .chat-header-status {
            font-size: 13px;
            color: #95a5a6;
        }

        .chat-header-actions {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .header-btn:hover {
            background: #5568d3;
        }

        /* Messages */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .message {
            display: flex;
            gap: 12px;
            max-width: 70%;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.sent {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
        }

        .message-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .message-bubble {
            background: white;
            padding: 12px 16px;
            border-radius: 18px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
        }

        .message.sent .message-bubble {
            background: #667eea;
            color: white;
        }

        .message-time {
            font-size: 11px;
            color: #95a5a6;
        }

        /* Input */
        .message-input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #ddd;
        }

        .message-input-wrapper {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 24px;
            font-size: 14px;
            resize: none;
            font-family: inherit;
            transition: border-color 0.3s;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .send-btn {
            width: 48px;
            height: 48px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }

        .send-btn:hover {
            background: #5568d3;
        }

        /* Online Users */
        .online-users-section {
            padding: 16px 20px;
            border-top: 1px solid #34495e;
        }

        .online-users-section h4 {
            color: #95a5a6;
            font-size: 12px;
            margin-bottom: 12px;
            text-transform: uppercase;
        }

        .online-user-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .online-user-item:hover {
            background: #34495e;
        }

        .online-user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .online-user-name {
            font-size: 13px;
            font-weight: 500;
        }

        .online-user-status {
            font-size: 11px;
            color: #95a5a6;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #27ae60;
        }

        .status-dot.away {
            background: #f39c12;
        }

        .status-dot.in-call {
            background: #e74c3c;
        }

        /* Call UI */
        .call-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            display: none;
        }

        .call-overlay.active {
            display: flex;
        }

        .call-container {
            background: #2c3e50;
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            color: white;
            min-width: 400px;
            max-width: 600px;
        }

        .call-status {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .call-participant {
            font-size: 16px;
            color: #95a5a6;
            margin-bottom: 24px;
        }

        .call-timer {
            font-size: 18px;
            color: #95a5a6;
            margin-bottom: 32px;
        }

        .call-controls {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-bottom: 24px;
        }

        .call-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 24px;
            transition: transform 0.2s, background 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .call-btn:hover {
            transform: scale(1.1);
        }

        .call-btn.accept {
            background: #27ae60;
            color: white;
        }

        .call-btn.reject {
            background: #e74c3c;
            color: white;
        }

        .call-btn.end {
            background: #e74c3c;
            color: white;
        }

        .call-btn.mute {
            background: #34495e;
            color: white;
        }

        .call-btn.mute.active {
            background: #e74c3c;
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2000;
            animation: slideInRight 0.3s ease-out;
            max-width: 320px;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Utility */
        .hidden {
            display: none !important;
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #95a5a6;
        }

        .empty-state h3 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 14px;
        }

        .new-conversation-btn {
            margin: 16px;
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }

        .new-conversation-btn:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
<!-- Auth Container -->
<div id="authContainer" class="auth-container">
    <div class="auth-box">
        <h2 id="authTitle">Login to Chat</h2>
        <div id="authError" class="error-message"></div>
        <div id="loginForm">
            <input type="text" id="loginUsername" placeholder="Username" />
            <input type="password" id="loginPassword" placeholder="Password" />
            <button onclick="login()">Login</button>
            <div class="toggle-link" onclick="toggleAuthMode()">Need an account? Register</div>
        </div>
        <div id="registerForm" class="hidden">
            <input type="text" id="registerUsername" placeholder="Username" />
            <input type="password" id="registerPassword" placeholder="Password" />
            <input type="text" id="registerDisplayName" placeholder="Display Name" />
            <button onclick="register()">Register</button>
            <div class="toggle-link" onclick="toggleAuthMode()">Already have an account? Login</div>
        </div>
    </div>
</div>

<!-- App Container -->
<div id="appContainer" class="app-container">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <div class="user-profile">
                <div class="user-avatar" id="userAvatar"></div>
                <div class="user-info">
                    <h3 id="userName"></h3>
                    <div class="user-status">
                        <div class="status-indicator"></div>
                        <span>Online</span>
                    </div>
                </div>
            </div>
        </div>

        <button class="new-conversation-btn" onclick="showNewConversationModal()">
            + New Conversation
        </button>

        <div id="conversationList" class="conversation-list"></div>

        <div class="online-users-section">
            <h4>Online Users</h4>
            <div id="onlineUsersList"></div>
        </div>
    </div>

    <!-- Chat Area -->
    <div class="chat-area">
        <div id="emptyState" class="empty-state">
            <h3>Welcome to Chat!</h3>
            <p>Select a conversation to start messaging</p>
        </div>

        <div id="chatView" class="hidden" style="display: flex; flex-direction: column; height: 100%;">
            <div class="chat-header">
                <div class="chat-header-info">
                    <h2 id="chatHeaderName"></h2>
                    <div class="chat-header-status" id="chatHeaderStatus"></div>
                </div>
                <div class="chat-header-actions">
                    <button class="header-btn" onclick="startCall()">ðŸ“ž Call</button>
                </div>
            </div>

            <div class="messages-container" id="messagesContainer"></div>

            <div class="message-input-container">
                <div class="message-input-wrapper">
                        <textarea
                                id="messageInput"
                                class="message-input"
                                placeholder="Type a message..."
                                rows="1"
                                onkeydown="handleMessageKeydown(event)"
                        ></textarea>
                    <button class="send-btn" onclick="sendMessage()">âž¤</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Call Overlay -->
<div id="callOverlay" class="call-overlay">
    <div class="call-container">
        <div class="call-status" id="callStatus">Incoming Call</div>
        <div class="call-participant" id="callParticipant"></div>
        <div class="call-timer" id="callTimer">00:00</div>
        <div class="call-controls" id="callControls"></div>
    </div>
</div>

<!-- New Conversation Modal -->
<div id="newConversationModal" class="modal hidden">
    <div class="modal-content">
        <div class="modal-header">New Conversation</div>
        <input type="text" id="recipientUserId" class="modal-input" placeholder="Enter User ID" />
        <div class="modal-actions">
            <button class="modal-btn secondary" onclick="closeModal()">Cancel</button>
            <button class="modal-btn primary" onclick="createConversation()">Create</button>
        </div>
    </div>
</div>

<script>
    // ==================== CONFIGURATION ====================
    const API_BASE = '';  // Same origin
    const WS_BASE = window.location.origin.replace('http', 'ws');

    // ==================== APPLICATION STATE ====================
    const state = {
        user: null,
        token: null,
        ws: null,
        currentConversation: null,
        conversations: [],
        messages: {},
        activeCall: null,
        typingTimeout: null,
        onlineUsers: {}
    };

    // ==================== INITIALIZATION ====================
    window.onload = function() {
        const token = localStorage.getItem('token');
        if (token) {
            state.token = token;
            loadUserData();
        }
    };

    // ==================== AUTH FUNCTIONS ====================
    function toggleAuthMode() {
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const title = document.getElementById('authTitle');

        if (loginForm.classList.contains('hidden')) {
            loginForm.classList.remove('hidden');
            registerForm.classList.add('hidden');
            title.textContent = 'Login to Chat';
        } else {
            loginForm.classList.add('hidden');
            registerForm.classList.remove('hidden');
            title.textContent = 'Register for Chat';
        }

        document.getElementById('authError').style.display = 'none';
    }

    async function login() {
        const username = document.getElementById('loginUsername').value;
        const password = document.getElementById('loginPassword').value;

        if (!username || !password) {
            showAuthError('Please fill in all fields');
            return;
        }

        try {
            const response = await fetch(`${API_BASE}/auth/login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });

            if (!response.ok) {
                const error = await response.json();
                showAuthError(error.error || 'Login failed');
                return;
            }

            const data = await response.json();
            state.token = data.token;
            state.user = data.user;
            localStorage.setItem('token', data.token);

            initializeApp();
        } catch (error) {
            showAuthError('Network error. Please try again.');
        }
    }

    async function register() {
        const username = document.getElementById('registerUsername').value;
        const password = document.getElementById('registerPassword').value;
        const displayName = document.getElementById('registerDisplayName').value;

        if (!username || !password || !displayName) {
            showAuthError('Please fill in all fields');
            return;
        }

        try {
            const response = await fetch(`${API_BASE}/auth/register`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password, displayName })
            });

            if (!response.ok) {
                const error = await response.json();
                showAuthError(error.error || 'Registration failed');
                return;
            }

            const data = await response.json();
            state.token = data.token;
            state.user = data.user;
            localStorage.setItem('token', data.token);

            initializeApp();
        } catch (error) {
            showAuthError('Network error. Please try again.');
        }
    }

    function showAuthError(message) {
        const errorEl = document.getElementById('authError');
        errorEl.textContent = message;
        errorEl.style.display = 'block';
    }

    async function loadUserData() {
        try {
            const response = await fetch(`${API_BASE}/users/me`, {
                headers: { 'Authorization': `Bearer ${state.token}` }
            });

            if (!response.ok) {
                localStorage.removeItem('token');
                return;
            }

            state.user = await response.json();
            initializeApp();
        } catch (error) {
            localStorage.removeItem('token');
        }
    }

    // ==================== MAIN APP INITIALIZATION ====================
    function initializeApp() {
        document.getElementById('authContainer').style.display = 'none';
        document.getElementById('appContainer').classList.add('active');

        // Set user info
        document.getElementById('userName').textContent = state.user.displayName;
        document.getElementById('userAvatar').textContent = state.user.displayName[0].toUpperCase();

        // Initialize WebSocket
        connectWebSocket();

        // Load conversations and users
        loadConversations();
        fetchAllUsers();

        // Refresh user status every 30 seconds
        setInterval(fetchAllUsers, 30000);
    }

    // ==================== WEBSOCKET FUNCTIONS ====================
    function connectWebSocket() {
        const wsUrl = `${WS_BASE}/ws?token=${state.token}`;
        console.log('Connecting to WebSocket:', wsUrl);
        state.ws = new WebSocket(wsUrl);

        state.ws.onopen = () => {
            console.log('WebSocket connected');
            // Send ping to keep connection alive
            setInterval(() => {
                if (state.ws.readyState === WebSocket.OPEN) {
                    state.ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 30000);
        };

        state.ws.onmessage = (event) => {
            try {
                console.log('Raw WebSocket message:', event.data);

                // Parse the message according to backend format
                const parsed = JSON.parse(event.data);
                console.log('Parsed message:', parsed);

                // The backend sends {type: "...", data: "..."} format
                // where data is a JSON string that needs to be parsed
                if (parsed.type && parsed.data) {
                    try {
                        const data = JSON.parse(parsed.data);
                        const message = {
                            type: parsed.type,
                            ...data
                        };
                        console.log('Final message object:', message);
                        handleWebSocketMessage(message);
                    } catch (innerError) {
                        // If data is not JSON, handle it as-is
                        console.log('Data is not JSON, using as string:', parsed.data);
                        const message = {
                            type: parsed.type,
                            data: parsed.data
                        };
                        handleWebSocketMessage(message);
                    }
                } else {
                    // Handle messages without the nested structure
                    handleWebSocketMessage(parsed);
                }
            } catch (error) {
                console.error('WebSocket parse error:', error);
            }
        };

        state.ws.onclose = (event) => {
            console.log('WebSocket disconnected, reconnecting...');
            setTimeout(connectWebSocket, 3000);
        };

        state.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
    }

    function handleWebSocketMessage(message) {
        console.log('Handling WebSocket message type:', message.type);

        switch (message.type) {
            case 'new_message':
                console.log('New message notification:', message);
                if (message.message) {
                    handleNewMessage(message.message);
                }
                break;
            case 'user_status':
                console.log('User status update:', message);
                if (message.userId && message.status) {
                    handleUserStatus({
                        userId: message.userId,
                        status: message.status
                    });
                }
                break;
            case 'call_initiated':
                console.log('Incoming call:', message);
                if (message.call && message.callerName) {
                    handleIncomingCall({
                        call: message.call,
                        callerName: message.callerName
                    });
                }
                break;
            case 'call_status':
                console.log('Call status update:', message);
                if (message.callId && message.status) {
                    handleCallStatus({
                        callId: message.callId,
                        status: message.status
                    });
                }
                break;
            case 'webrtc_offer':
            case 'webrtc_answer':
            case 'ice_candidate':
                console.log('WebRTC signal:', message.type);
                handleWebRTCSignal(message);
                break;
            case 'pong':
                // Keep-alive response
                break;
            default:
                console.log('Unknown message type:', message.type);
        }
    }

    function sendWebSocketMessage(type, data) {
        if (state.ws && state.ws.readyState === WebSocket.OPEN) {
            const message = {
                type: type,
                data: JSON.stringify(data)
            };
            console.log('Sending WebSocket message:', message);
            state.ws.send(JSON.stringify(message));
        }
    }

    // ==================== API FUNCTIONS ====================
    async function apiRequest(endpoint, options = {}) {
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${state.token}`,
            ...options.headers
        };

        try {
            const response = await fetch(`${API_BASE}${endpoint}`, {
                ...options,
                headers
            });

            if (!response.ok && response.status !== 204) {
                const error = await response.text();
                throw new Error(`API error: ${response.status} - ${error}`);
            }

            if (response.status === 204) return null;
            return await response.json();
        } catch (error) {
            console.error(`API request failed for ${endpoint}:`, error);
            showToast('Error', 'Request failed');
            throw error;
        }
    }

    // ==================== CONVERSATION FUNCTIONS ====================
    async function loadConversations() {
        try {
            const dms = await apiRequest('/dms');
            state.conversations = dms;
            renderConversationList();
        } catch (error) {
            console.error('Error loading conversations:', error);
        }
    }

    function renderConversationList() {
        const list = document.getElementById('conversationList');

        if (state.conversations.length === 0) {
            list.innerHTML = '<div style="padding: 20px; text-align: center; color: #95a5a6;">No conversations yet</div>';
            return;
        }

        list.innerHTML = state.conversations.map(conv => {
            const isActive = state.currentConversation && state.currentConversation.id === conv.id;
            const statusColor = conv.otherUser.status === 'ONLINE' ? '#27ae60' :
                conv.otherUser.status === 'AWAY' ? '#f39c12' :
                    conv.otherUser.status === 'IN_CALL' ? '#e74c3c' : '#95a5a6';

            // Get last message preview if available
            let lastMessagePreview = 'No messages yet';
            let lastMessageTime = '';

            if (state.messages[conv.id] && state.messages[conv.id].length > 0) {
                const lastMsg = state.messages[conv.id][state.messages[conv.id].length - 1];
                lastMessagePreview = lastMsg.content.length > 30
                    ? lastMsg.content.substring(0, 30) + '...'
                    : lastMsg.content;
                lastMessageTime = formatTime(lastMsg.createdAt);
            } else if (conv._lastMessage) {
                // Fallback to cached preview
                lastMessagePreview = conv._lastMessage.length > 30
                    ? conv._lastMessage.substring(0, 30) + '...'
                    : conv._lastMessage;
                lastMessageTime = conv._lastMessageTime ? formatTime(conv._lastMessageTime) : '';
            }

            return `
            <div class="conversation-item ${isActive ? 'active' : ''}"
                 onclick="selectConversation('${conv.id}')">
                <div class="conversation-header">
                    <span class="conversation-name">${conv.otherUser.displayName}</span>
                    <span class="conversation-time">
                        <span style="display: inline-flex; align-items: center; gap: 4px;">
                            <span style="width: 6px; height: 6px; border-radius: 50%; background: ${statusColor};"></span>
                            ${conv.otherUser.status}
                        </span>
                        ${lastMessageTime ? `<br><small>${lastMessageTime}</small>` : ''}
                    </span>
                </div>
                <div class="conversation-preview" title="${conv._lastMessage || 'No messages'}">
                    ${lastMessagePreview}
                </div>
            </div>
        `;
        }).join('');
    }

    async function selectConversation(conversationId) {
        const conversation = state.conversations.find(c => c.id === conversationId);
        if (!conversation) return;

        state.currentConversation = conversation;

        document.getElementById('emptyState').classList.add('hidden');
        document.getElementById('chatView').classList.remove('hidden');

        document.getElementById('chatHeaderName').textContent = conversation.otherUser.displayName;
        document.getElementById('chatHeaderStatus').textContent = conversation.otherUser.status;

        await loadMessages(conversationId);
        renderConversationList();
    }

    async function createConversation() {
        const recipientId = document.getElementById('recipientUserId').value.trim();
        if (!recipientId) return;

        try {
            const dm = await apiRequest('/dms', {
                method: 'POST',
                body: JSON.stringify({ recipientId })
            });

            state.conversations.push(dm);
            closeModal();
            selectConversation(dm.id);
            renderConversationList();
        } catch (error) {
            console.error('Error creating conversation:', error);
            showToast('Error', 'Failed to create conversation');
        }
    }

    function showNewConversationModal() {
        // Simple prompt for now
        const recipientId = prompt('Enter User ID to start conversation:');
        if (recipientId) {
            document.getElementById('recipientUserId').value = recipientId;
            createConversation();
        }
    }

    function closeModal() {
        document.getElementById('newConversationModal').classList.add('hidden');
    }

    // ==================== MESSAGE FUNCTIONS ====================
    async function loadMessages(conversationId) {
        try {
            const response = await apiRequest(`/dms/${conversationId}/messages`);
            state.messages[conversationId] = response.messages.reverse();
            renderMessages();
        } catch (error) {
            console.error('Error loading messages:', error);
        }
    }

    function renderMessages() {
        if (!state.currentConversation) return;

        const container = document.getElementById('messagesContainer');
        const messages = state.messages[state.currentConversation.id] || [];

        container.innerHTML = messages.map(msg => {
            const isSent = msg.senderId === state.user.id;

            return `
                    <div class="message ${isSent ? 'sent' : ''}">
                        <div class="message-avatar">${msg.senderName[0].toUpperCase()}</div>
                        <div class="message-content">
                            ${!isSent ? `<div class="message-sender">${msg.senderName}</div>` : ''}
                            <div class="message-bubble">${escapeHtml(msg.content)}</div>
                            <div class="message-time">${formatTime(msg.createdAt)}</div>
                        </div>
                    </div>
                `;
        }).join('');

        container.scrollTop = container.scrollHeight;
    }

    async function sendMessage() {
        if (!state.currentConversation) return;

        const input = document.getElementById('messageInput');
        const content = input.value.trim();
        if (!content) return;

        try {
            await apiRequest(`/dms/${state.currentConversation.id}/messages`, {
                method: 'POST',
                body: JSON.stringify({ content })
            });

            input.value = '';
            input.style.height = 'auto';
        } catch (error) {
            console.error('Error sending message:', error);
        }
    }

    function handleMessageKeydown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    }

    function handleNewMessage(message) {
        console.log('New message received:', message);

        const conversationId = message.dmId || message.groupId;
        if (!conversationId) return;

        // Initialize messages array for this conversation if needed
        if (!state.messages[conversationId]) {
            state.messages[conversationId] = [];
        }

        // Check if message already exists
        const exists = state.messages[conversationId].some(m => m.id === message.id);
        if (!exists) {
            // Add message
            state.messages[conversationId].push(message);

            // Sort by timestamp (oldest first)
            state.messages[conversationId].sort((a, b) =>
                new Date(a.createdAt) - new Date(b.createdAt)
            );

            // If this is the current conversation, update UI
            if (state.currentConversation && state.currentConversation.id === conversationId) {
                renderMessages();
            }

            // Update conversation list to show latest message preview
            updateConversationPreview(conversationId, message);

            // Show notification if not current conversation
            if (!state.currentConversation || state.currentConversation.id !== conversationId) {
                const preview = message.content.length > 50
                    ? message.content.substring(0, 50) + '...'
                    : message.content;
                showToast('New Message', `${message.senderName}: ${preview}`);
            }
        }
    }

    function updateConversationPreview(conversationId, latestMessage) {
        // Find the conversation
        const convIndex = state.conversations.findIndex(c => c.id === conversationId);
        if (convIndex !== -1) {
            // Update the conversation with latest message preview
            const conv = state.conversations[convIndex];

            // Create a copy to trigger re-render
            state.conversations = [...state.conversations];
            state.conversations[convIndex] = {
                ...conv,
                _lastMessage: latestMessage.content,
                _lastMessageTime: latestMessage.createdAt
            };

            // Re-render conversation list
            renderConversationList();
        }
    }

    // ==================== USER FUNCTIONS ====================
    async function fetchAllUsers() {
        try {
            const users = await apiRequest('/users/all');

            // Update online users state
            state.onlineUsers = {};
            users.forEach(user => {
                state.onlineUsers[user.id] = user;

                // Update status in conversations
                state.conversations.forEach(conv => {
                    if (conv.otherUser.id === user.id) {
                        conv.otherUser.status = user.status;
                    }
                });
            });

            renderConversationList();
            renderOnlineUsers();
        } catch (error) {
            console.error('Error fetching users:', error);
        }
    }

    function renderOnlineUsers() {
        const container = document.getElementById('onlineUsersList');
        const onlineUsers = Object.values(state.onlineUsers).filter(user =>
            user.id !== state.user.id &&
            (user.status === 'ONLINE' || user.status === 'AWAY' || user.status === 'IN_CALL')
        );

        if (onlineUsers.length === 0) {
            container.innerHTML = '<div style="color: #95a5a6; font-size: 12px; text-align: center;">No other users online</div>';
            return;
        }

        container.innerHTML = onlineUsers.map(user => {
            const statusClass = user.status === 'ONLINE' ? '' :
                user.status === 'AWAY' ? 'away' :
                    user.status === 'IN_CALL' ? 'in-call' : '';

            return `
            <div class="online-user-item" onclick="startChatWithUser('${user.id}')">
                <div class="online-user-avatar">${user.displayName[0].toUpperCase()}</div>
                <div class="online-user-info">
                    <div class="online-user-name">${user.displayName}</div>
                    <div class="online-user-status">
                        <span class="status-dot ${statusClass}"></span>
                        ${user.status}
                    </div>
                </div>
            </div>
        `;
        }).join('');
    }

    async function startChatWithUser(userId) {
        try {
            const dm = await apiRequest('/dms', {
                method: 'POST',
                body: JSON.stringify({ recipientId: userId })
            });

            // Add to conversations if not already there
            const exists = state.conversations.some(c => c.id === dm.id);
            if (!exists) {
                state.conversations.push(dm);
            }

            selectConversation(dm.id);
            renderConversationList();
            renderOnlineUsers();
        } catch (error) {
            console.error('Error starting chat:', error);
            showToast('Error', 'Failed to start chat');
        }
    }

    function handleUserStatus(data) {
        console.log('Updating user status:', data);

        // Update in onlineUsers state
        if (state.onlineUsers[data.userId]) {
            state.onlineUsers[data.userId].status = data.status;
        }

        // Update in conversations
        let needsUpdate = false;
        state.conversations.forEach((conv, index) => {
            if (conv.otherUser.id === data.userId && conv.otherUser.status !== data.status) {
                // Create new array to trigger re-render
                state.conversations = [...state.conversations];
                state.conversations[index] = {
                    ...conv,
                    otherUser: {
                        ...conv.otherUser,
                        status: data.status
                    }
                };
                needsUpdate = true;
            }
        });

        // Update current chat header if needed
        if (state.currentConversation &&
            state.currentConversation.otherUser.id === data.userId &&
            state.currentConversation.otherUser.status !== data.status) {

            state.currentConversation.otherUser.status = data.status;
            document.getElementById('chatHeaderStatus').textContent = data.status;

            // Also update in conversations array
            const convIndex = state.conversations.findIndex(c => c.id === state.currentConversation.id);
            if (convIndex !== -1) {
                state.conversations[convIndex].otherUser.status = data.status;
            }
            needsUpdate = true;
        }

        // Re-render if anything changed
        if (needsUpdate) {
            renderConversationList();
            renderOnlineUsers();
        }
    }

    // ==================== CALL FUNCTIONS (SIMPLIFIED) ====================
    async function startCall() {
        if (!state.currentConversation) {
            showToast('Error', 'Select a conversation first');
            return;
        }

        try {
            const recipientId = state.currentConversation.otherUser.id;
            const call = await apiRequest('/calls/initiate', {
                method: 'POST',
                body: JSON.stringify({ recipientId })
            });

            state.activeCall = call;
            showCallUI('Calling...', state.currentConversation.otherUser.displayName);
            showToast('Call Started', 'Calling ' + state.currentConversation.otherUser.displayName);
        } catch (error) {
            console.error('Error starting call:', error);
            showToast('Error', 'Failed to start call');
        }
    }

    function handleIncomingCall(data) {
        state.activeCall = data.call;
        showCallUI('Incoming Call', data.callerName, true);
    }

    function handleCallStatus(data) {
        if (!state.activeCall || state.activeCall.id !== data.callId) return;

        if (data.status === 'ACTIVE') {
            state.activeCall.status = 'ACTIVE';
            showCallUI('In Call', getCallParticipantName());
            startCallTimer();
        } else if (data.status === 'ENDED') {
            hideCallUI();
            showToast('Call Ended', 'The call has ended');
            state.activeCall = null;
        }
    }

    async function acceptCall() {
        if (!state.activeCall) return;

        try {
            await apiRequest(`/calls/${state.activeCall.id}/accept`, {
                method: 'POST'
            });

            showCallUI('In Call', getCallParticipantName());
            startCallTimer();
            showToast('Call Accepted', 'You are now in the call');
        } catch (error) {
            console.error('Error accepting call:', error);
            showToast('Error', 'Failed to accept call');
        }
    }

    async function rejectCall() {
        if (!state.activeCall) return;

        try {
            await apiRequest(`/calls/${state.activeCall.id}/reject`, {
                method: 'POST'
            });

            hideCallUI();
            state.activeCall = null;
        } catch (error) {
            console.error('Error rejecting call:', error);
        }
    }

    async function endCall() {
        if (!state.activeCall) return;

        try {
            await apiRequest(`/calls/${state.activeCall.id}/end`, {
                method: 'POST'
            });

            hideCallUI();
            state.activeCall = null;
            showToast('Call Ended', 'Call ended');
        } catch (error) {
            console.error('Error ending call:', error);
        }
    }

    function showCallUI(status, participant, isIncoming = false) {
        const overlay = document.getElementById('callOverlay');
        const statusEl = document.getElementById('callStatus');
        const participantEl = document.getElementById('callParticipant');
        const controlsEl = document.getElementById('callControls');

        overlay.classList.add('active');
        statusEl.textContent = status;
        participantEl.textContent = participant;

        if (isIncoming) {
            controlsEl.innerHTML = `
                    <button class="call-btn accept" onclick="acceptCall()" title="Accept">âœ“</button>
                    <button class="call-btn reject" onclick="rejectCall()" title="Reject">âœ—</button>
                `;
        } else {
            controlsEl.innerHTML = `
                    <button class="call-btn end" onclick="endCall()" title="End Call">âœ—</button>
                `;
        }
    }

    function hideCallUI() {
        const overlay = document.getElementById('callOverlay');
        overlay.classList.remove('active');
        document.getElementById('callTimer').textContent = '00:00';

        if (state.callTimer) {
            clearInterval(state.callTimer);
            state.callTimer = null;
        }
    }

    function startCallTimer() {
        let seconds = 0;
        state.callTimer = setInterval(() => {
            seconds++;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('callTimer').textContent =
                `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }, 1000);
    }

    function getCallParticipantName() {
        if (!state.activeCall) return '';
        return state.currentConversation?.otherUser.displayName || 'Unknown';
    }

    // ==================== WEBRTC SIGNAL HANDLING (SIMPLIFIED) ====================
    function handleWebRTCSignal(message) {
        console.log('WebRTC signal received:', message.type);
        // For now, just log WebRTC signals
        // In a real implementation, this would handle SDP and ICE candidates
    }

    // ==================== UTILITY FUNCTIONS ====================
    function formatTime(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diff = now - date;

        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);

        if (minutes < 1) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        if (days < 7) return `${days}d ago`;

        return date.toLocaleDateString();
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function showToast(title, message, duration = 5000) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.innerHTML = `
                <div class="toast-title">${title}</div>
                <div class="toast-body">${escapeHtml(message)}</div>
            `;

        document.body.appendChild(toast);

        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, duration);

        return toast;
    }

    // ==================== MODAL STYLES (Inline for simplicity) ====================
    const style = document.createElement('style');
    style.textContent = `
            .modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
                align-items: center;
                justify-content: center;
            }

            .modal-content {
                background: white;
                border-radius: 12px;
                padding: 24px;
                width: 90%;
                max-width: 400px;
            }

            .modal-header {
                font-size: 20px;
                font-weight: 600;
                margin-bottom: 20px;
                color: #2c3e50;
            }

            .modal-input {
                width: 100%;
                padding: 12px;
                margin-bottom: 16px;
                border: 2px solid #e0e0e0;
                border-radius: 8px;
                font-size: 14px;
            }

            .modal-input:focus {
                outline: none;
                border-color: #667eea;
            }

            .modal-actions {
                display: flex;
                gap: 12px;
                justify-content: flex-end;
            }

            .modal-btn {
                padding: 10px 20px;
                border: none;
                border-radius: 6px;
                font-weight: 600;
                cursor: pointer;
                transition: background 0.3s;
            }

            .modal-btn.primary {
                background: #667eea;
                color: white;
            }

            .modal-btn.primary:hover {
                background: #5568d3;
            }

            .modal-btn.secondary {
                background: #e0e0e0;
                color: #2c3e50;
            }

            .modal-btn.secondary:hover {
                background: #d0d0d0;
            }
        `;
    document.head.appendChild(style);
</script>
</body>
</html>